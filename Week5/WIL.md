# UI 구성 방식

## Imperative UI (명령형)
'어떻게' 구성하는지 명시
전통적인 방식, 정보를 정확히 전달해야함 

e.g., 사각형을 그리기 위해서는 기계에게 사각형의 정의까지 알려줘야함
## Declaratice UI (선언형)
'무엇을' 구성하는지 명시
e.g., 기계가 사각형을 알고 있기에 정의가 무엇인지 몰라도 됨.

F(State) = View 함수에 인자로 State를 넘겨주면 그것을 View로 보여준다는 공식
즉, 커다란 골조는 완성되어있고 그 안에 어떤 상태를 명시해주는 방식으로 View 구성

--> 지금 학습하는 Flutter는 Declaratice UI 방식으로 View 그림

# State
데이터들을 일반적으로 상태로 표현 -> 보여주고자 하는 데이터 혹은 모습

## AppDate
앱 전반에서 사용되는 데이터
AppData의 변경점을 다른 페이지에서도 보여줘야함
## WidgetData
위젯에서 사용되는 데이터 -> 다른 페이지에서 필수적으로 변경하지 않아도 됨

# Stateless & Stateful


## Stateless
여태 이용한 것들 모두 Stateless Widget 
상태가 없다는 것은 표현할 모습이나 데이터가 없다는 것
첫모습이 보여줄 전부, 정적임, 새로고침이 없는 위젯
## Stateful
상태있음, 동적, 새로고침이 있는 위젯
유저상호작용이 있는 앱들은 대부분 Stateful Widget으로 제작

### setState함수
매개변수로 람다 함수를 넣어줌으로써 상태 변화시킨 것을 적용할 수 있음
즉, 역할은 위젯을 다시 그려주는 것
setState(() {}) 의 매개변수는 위젯을 다시 그려주기 전에 수행할 명령어 집합



